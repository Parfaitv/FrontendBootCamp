<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 1</title>
</head>
<body>
    <h2>Сравнение открытых OLAP-систем <br> Big Data: ClickHous, Druid и Pinot</h2>
    <p>
        <a href="#">ClickHouse</a>, <a href="#">Druid</a> и <a href="#">Pinot</a> - три открытых хранилища данных, которые позволяют<br>
        выполнять аналитические запросы на больших объемах данных с интерактивными<br>
        задержками. Эта статья - перевод <a href="#">подробного сравнения</a>, выполненного Романом<br>Левентовым.
    </p>

    <h3>Источники информации</h3>
    <p>
        Подробности реализации <b>ClickHouse</b> стали мне известны от <a href="#">Алексея Зателепина</a>,<br>
        одного из <b>ключевых разработчиков проекта</b>. Доступная на английском <br>
        документация достаточно скудна – наилучшим источником информации служат<br>
        последние четыре секции <a href="#">данной страницы документации</a>.
    </p>
    <p>
        <b>Я сам участвую в развитии Druid</b>, но у меня нет личной заинтересованности в этой<br>
        системе - по правде говоря, скорее всего в ближайшее время я перестану заниматься<br>
        её разработкой. Поэтому читатели могут рассчитывать на отсутствие какой-либо<br>
        предвзятости.
    </p>
    <p>
        Всё, что я буду далее писать про <b>Pinot</b>, основывается на странице <a href="#"> Архитектура в вики<br>
        Pinot</a>, а также на других страницах вики в разделе “Проектная документация”.<br>
        Последний раз они обновлялись в июне 2017 года - больше, чем полгода назад.
    </p>
    <p>
        Рецензентами оригинальной статьи стали Алексей Зателепин и <a href="#">Виталий Людвиченко</a><br>
        (разработчики ClickHouse), <a href="#">Жан Мерлино</a> (самый активный разработчик Druid), <a href="#">Кишор<br>
        Гопалакришна</a> (архитектор Pinot) и <a href="#">Жан-Француа Им</a> (разработчик Pinot). Мы<br>
        присоединяемся к благодарности автора и полагаем, что это многократно повышает<br>
        авторитетность статьи.
    </p>
    <p>
        <b>Предупреждение</b>: статья достаточно большая, поэтому вполне возможно вы захотите<br>
        ограничиться прочтением раздела “Заключение” в конце.
    </p>

    <h2>Сходства между системами</h2>

    <h3>Связанные данные и вычисления</h3>
    <p>
        <b>На фундаментальном уровне, ClickHouse, Druid и Pinot похожи</b>, поскольку они<br>
        хранят данные и выполняют обработку запросов на одних и тех же узлах, уходя от<br>
        “разъединенной” архитектуры BigQuery. Недавно я уже описывал несколько<br>
        наследственных проблем со связанной архитектурой в случае Druid [<a href="#">1</a>, <a href="#">2</a>]. Открытого<br>
        эквивалента для BigQuery на данный момент не существует (за исключением, разве<br>
        что, <a href="#">Drill</a>?) Возможным подходам к построению подобных открытых систем посвящена<br>
        <a href="#">другая статье в моем блоге.</a>
    </p>
    <h3>Отличия от Big Data SQL-систем: индексы и статическое<br>
        распределение данных</h3>
    <p>
        Рассматриваемые в этой статье системы<b> выполняют запросы быстрее</b>, чем<br>
        системы Big Data из семейства класса SQL-on-Hadoop: Hive, Impala, Presto и Spark,<br>
        даже когда последние получают доступ к данным, хранящимся в колоночном формате<br>
        - к примеру, Parquet или Kudu. Это происходит потому, что в ClickHouse, Druid и Pinot:<br>
    </p>
    <p>
        <ul>
            <li>
                Имеется <b>свой собственный формат для хранения данных с индексами</b>, и<br>
                они тесно интегрированы с движками обработки запросов. Системы класса<br>
                SQL-on-Hadoop обычно можно назвать агностиками относительно форматов<br>
                данных и поэтому они менее “навязчивы” в бэкендах Big Data.<br>
                
            </li>
            <li>
                <b>Данные распределены относительно “статично”</b> между узлами, и при<br>
                распределенном выполнении запроса это можно использовать. Обратная<br>
                сторона медали при этом в том, что ClickHouse, Druid и Pinot <b>не поддерживают<br>
                запросы, которые требуют перемещения большого количества данных</b><br>
                между узлами - к примеру, join между двумя большими таблицами.<br>
            </li>
        </ul>
    </p>
    <h3>Отсутствие точечных обновлений и удалений</h3>
    <p>
        Находясь на другой стороне спектра баз данных, ClickHouse, Druid и Pinot <b>не<br>
        поддерживают точечные обновления и удаления</b>, в противоположность<br>
        колоночным системам вроде Kudu, InfluxDB и Vertica (?). Это даёт ClickHouse, Druid и<br>
        Pinot возможность производить более эффективное колоночное сжатие и более<br>
        агрессивные индексы, что означает <b>большую эффективность использования<br>
        ресурсов</b> и быстрое выполнение запросов.<br>
    </p>
    <p>
        Разработчики ClickHouse в Yandex планируют начать поддерживать <a href="#">обновления и<br>
        удаления в будущем</a>, но я не уверен, будут ли это “настоящие” точечные запросы или<br>
        обновления/удаления диапазонов данных.<br>
    </p>
    <h3>Поглощение в стиле Big Data</h3>
    <p>
        Все три системы поддерживают потоковое поглощение данных из Kafka. Druid и Pinot<br>
        поддерживают потоковую передачу данных стриминг в <a href="#">Лямбда-стиле</a> и пакетное<br>
        поглощение одних и тех же данных. ClickHouse поддерживает пакетные вставки<br>
        напрямую, поэтому ему не требуется отдельная система пакетного поглощения<br>
        подобная той, что используется в Druid и Pinot. Если вас интересуют подробности, то<br>
        их вы сможете найти далее.<br>
    </p>
    <h3>Проверено на крупном масштабе</h3>
    <p>
        Все три системы проверены на работоспособность в крупных масштабах: в<br>
        <a href="#">Yandex.Metrica работает кластер ClickHouse</a>, состоящий из примерно десятка тысяч<br>
        ядер CPU. В Metamarkets используется <a href="#">кластер Druid аналогичного размера</a>. Один<br>
        кластер Pinot в LinkedIn включает в себя “<a href="#">тысячи машин</a>”.<br>
    </p>
    <h3>Незрелость</h3>
    <p>
        Все рассматриваемые в статье системы являются <b>незрелыми по меркам открытых<br>
        enterprise-систем Big Data</b>. Однако, скорее всего они незрелы не более, чем<br>
        среднестатистическая открытая система Big Data - но это совсем другая история. В<br>
        ClickHouse, Druid и Pinot недостает некоторых очевидных оптимизаций и<br>
        функциональности, и они кишат багами (насчет ClickHouse и Pinot я не уверен на все<br>
        100%, но не вижу причин, по которым они в этом плане были бы лучше Druid).<br>
    </p>
    <p>Это плавно подводит нас к следующему важному разделу.</p>
    <h2>Про сравнение производительности и выбор<br>системы</h2>
    <p>
        Я регулярно вижу в сети, как некоторые проводят сравнения систем больших данных:<br>
        они берут набор своих данных, каким-либо образом “скармливают” его оцениваемой<br>
        системе, а затем немедленно пытаются измерить производительность - сколько<br>
        памяти или дискового пространства было занято, и насколько быстро выполнялись<br>
        запросы. Причем понимание того, как устроены изнутри испытываемые ими системы, у<br>
        них отсутствует. Затем, используя лишь подобные специфичные данные о<br>
        производительности - иногда вместе со списками функциональности, которая им<br>
        нужна и которая есть в системе <i>на настоящий момент</i>, - они в итоге делают свой<br>
        выбор или, что еще хуже, выбирают написать свою собственную, “лучшую” систему с<br>
        нуля.
    </p>
    <p>
        Такой подход мне кажется неправильным, по крайней мере он неприменим в<br>
        отношении открытых OLAP-систем для Big Data. Задача создания системы Bid Data<br>
        OLAP, которая смогла бы работать эффективно в большинстве сценариев<br>
        использования и содержала бы все необходимые функции настолько велика, что я<br>
        оцениваю ее реализацию как минимум в <b>100 человеко-лет</b>.<br>
    </p>
    <p>
        На сегодня, ClickHouse, Druid и Pinot оптимизированы <i>только</i> для конкретных<br>
        сценариев использования, которые требуются их разработчиком - и содержат по<br>
        большей части лишь те функции, в которых нуждаются сами разработчики. Я могу<br>
        гарантировать, что ваш случай обязательно “упрется” в те узкие места, с которыми<br>
        разработчики рассматриваемых OLAP-систем еще не сталкивались - или же в те<br>
        места, что их не интересуют.
    </p>
    <p>
        Не говоря уже о том, что упомянутый выше подход “забросить данные в систему, о<br>
        которой вы ничего не знаете, и затем измерить её эффективность” весьма вероятно<br>
        даст искаженный результат из-за серьезных “узких” мест, которые на самом деле<br>
        могли бы быть исправлены <b>простым изменением конфигурации</b>, схемы данных или<br>
        другим построением запроса.
    </p>
    <h3>CloudFlare: ClickHouse против Druid</h3>
    <p>
        Одним таким примером, хорошо иллюстрирующим описанную выше проблему,<br>
        является пост Марека Вавруша о <a href="#">выборе между ClickHouse и Druid в Cloudflare</a>. Им<br>
        потребовалось 4 сервера ClickHouse (которые со временем превратились в 9), и по их<br>
        оценкам, для разворачивания аналогичной установки Druid им бы потребовались<br>
        “сотни узлов”. Пусть Марек и признает, что <b>сравнение является нечестным</b>,<br>
        поскольку Druid недостаёт “сортировки по первичному ключу”, он возможно даже не<br>
        осознает, что достичь примерно того же самого эффекта в Druid возможно просто<br>
        <a href="#">установив правильный порядок измерений в “<em>ingestion spec</em>”</a> и произведя простую<br>
        подготовку данных: обрезать значение колонки <i>__time</i> в Druid до некоей грубой<br>
        детализации (к примеру, один час) и опционально добавить другую “длинно-типовую”<br>
        колонку “precise_time”, если для некоторых запросов требуются более точные<br>
        временные рамки. Да, это хак, но, как мы только что выяснили, и в Druid можно<br>
        сортировать данные по какому-либо измерению перед <i>__time</i>, и это достаточно<br>
        просто реализовать.
    </p>
    <p>
        Впрочем, я не стану спорить с их итоговым решением выбрать ClickHouse, поскольку<br>
        на масштабе примерно в 10 узлов и для их нужд ClickHouse мне тоже кажется лучшим<br>
        выбором, чем Druid. Но сделанное ими заключение о том, что ClickHouse как минимум<br>
        на порядок эффективнее (по меркам стоимости инфраструктуры), чем Druid - это<br>
        серьезное заблуждение. На самом деле, из рассматриваемых нами сегодня систем,<br>
        <b>Druid предлагает наилучшую возможность для реально дешевых установок</b><br>
        (смотрите раздел “Уровни узлов обработки запросов в Druid ” ниже)<br>
    </p>
    <p>
        <q>
            Когда вы выбираете систему OLAP Big Data, не сравнивайте то, насколько они<br>
            сейчас хорошо подходят для вашего случая. Сейчас они все субоптимальны.<br>
            Вместо этого, сравните, насколько быстро ваша компания способна заставить<br>
            двигаться эти системы в том направлении, которое нужно именно вам.
        </q><br>
    </p>
    <p>
        В силу своей фундаментальной архитектурной схожести, ClickHouse, Druid и Pinot<br>
        имеют примерно один и тот же “предел” эффективности и оптимизации<br>
        производительности. Здесь нет “волшебной таблетки”, которая позволила бы какой-<br>
        либо из этих систем быть быстрее, чем остальные. Не позволяйте запутать себя тем<br>
        фактом, что <em>в своем текущем состоянии</em> системы показывают себя очень по-разному<br>
        в различных бенчмарках.<br>
    </p>
    <p>
        Допустим, Druid не поддерживает “сортировку по первичному ключу” настолько<br>
        хорошо, насколько это умеет ClickHouse - а ClickHouse в свою очередь не<br>
        поддерживает “инвертированные индексы” столь же хорошо, как Druid, что дает<br>
        данным системам преимущества с той или иной нагрузкой. <b>Упущенные оптимизации<br>
        могут быть реализованы в выбранной системе при помощи не таких уж и<br>
        больших усилий</b>, если у вас есть намерение и возможность решиться на подобный<br>
        шаг.
    </p>
    <p>
        <ul>
            <li>
                В вашей организации должны быть инженеры, способные прочитать, понять и<br>
                модифицировать исходный код выбранной системы, к тому же у них должно<br>
                быть на это время. Заметьте, что ClickHouse написан на C++, а Druid и Pinot —<br>
                на Java.
            </li>
            
        </ul>
    </p>
    <p>
        <ul>
            <li>
                Или же ваша организация должна подписать контракт с компанией, которая<br>
                оказывает поддержку выбранной системы. Это будут <a href="#">Altinity</a> для ClickHouse,<br>
                <a href="#">Imply</a> и <a href="#">Hortonworks</a> для Druid. Для Pinot таких компаний в данный момент нет.<br>
            </li>
        </ul>
    </p>
    <p>Другие сведения о разработке систем, которые вам стоит принять во внимание:</p>
    <p>
        <ul>
            <li>
                Авторы ClickHouse, работающие в Yandex, утверждают, что они тратят 50%<br>
                своего времени на создание функциональности, которая требуется им внутри<br>
                компании, и другие 50% уходят на функции, который набирают большинство<br>
                “голосов сообщества”. Однако, чтобы вы получили от этого факта<br>
                преимущество, требуется, чтобы <b>функции, которые нужны вам, были и<br>
                наиболее востребованы сообществом</b> ClickHouse.
            </li>
            <li>
                Разработчики Druid из Imply мотивированы работать над широко<br>
                используемыми функциями, поскольку это позволит им максимально увеличить<br>
                объем охвата своего бизнеса в будущем.
            </li>
            <li>
                Процесс разработки Druid сильно напоминает <a href="#">модель Apache</a>, когда ПО<br>
                несколько лет разрабатывается несколькими компаниями, у каждой из который<br>
                достаточно своеобразные и различные приоритеты, и среди них нет ведущей<br>
                компании. ClickHouse и Pinot пока еще далеки от подобного этапа, поскольку<br>
                ими занимаются соответственно лишь Yandex и Linkedin. Сторонний вклад в<br>
                развитие Druid имеет минимальный шанс быть отклоненным в силу того, что он<br>
                расходится с видением основного разработчика - ведь <b>в Druid нет “основной”<br>
                компании-разработчика</b>.
            </li>
            <li>
                Druid поддерживает “API разработчика”, который позволяет привносить<br>
                собственные типы колонок, механизмы агрегации, возможные варианты для<br>
                «глубокого хранения» и пр., причем все это вы можете держать в кодовой базе,<br>
                отдельной от самого ядра Druid. Данное API документировано разработчиками<br>
                Druid, и они следят за его совместимостью с предыдущими версиями. Однако,<br>
                оно недостаточно “взрослое”, и ломается практически с каждым новым релизом<br>
                Druid. Насколько мне известно, в ClickHouse и Pinot схожие API не<br>
                поддерживаются.
            </li>
            <li>
                Согласно Github, <b>над Pinot работает наибольшее число людей</b> - по всей<br>
                видимости, лишь за прошлый год в Pinot было вложено <a href="#">не менее 10 человеко-<br>
                лет</a>. Для ClickHouse эта цифра составляет примерно 6 человеко-лет, а для<br>
                Druid - 7. В теории, это должно означать, что Pinot улучшается быстрее всех<br>
                остальных систем, которые мы рассматриваем.
            </li>
        </ul>
    </p>
</body>
</html>